name: GMX Tests

# NOTE: GMX tests are separated into their own workflow because:
# - They require special handling and may have issues with parallel execution
# - They need extensive debugging and comments about what doesn't work
# - They interact with live/mainnet fork environments that may have race conditions
# - Order execution depends on off-chain keepers which makes parallel testing potentially problematic
# - Currently running in parallel mode, but see comments below about known issues

on:
  push:
    branches: [ master ]
    paths:
      - 'eth_defi/gmx/**'
      - 'tests/gmx/**'
      - '.github/workflows/test-gmx.yml'
  pull_request:
    branches: [ master ]
    paths:
      - 'eth_defi/gmx/**'
      - 'tests/gmx/**'
      - '.github/workflows/test-gmx.yml'

jobs:
  test-gmx-serial:
    # Reserved multicore instance for running tests
    runs-on:
      group: Beefy runners

    # Only run the action for the latest push
    # See https://docs.github.com/en/actions/using-jobs/using-concurrency#example-only-cancel-in-progress-jobs-or-runs-for-the-current-workflow
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.python-version }}
      cancel-in-progress: true

    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.12"]

    name: GMX Tests - Python ${{ matrix.python-version }}

    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          # Disable cache to force fresh installation when debugging
          # cache: "poetry"

      # https://github.com/python-poetry/poetry/blob/main/CHANGELOG.md
      - name: Install poetry (using matrix Python)
        run: pipx install "poetry>=2.3" --python "${{ env.PYTHON_PATH }}"

      # Install dependencies with the specific Web3.py version
      # Using a single installation command to avoid conflicts
      - name: Install dependencies
        run: |
            poetry install
            poetry install -E docs -E data -E test -E hypersync -E ccxt -E duckdb

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          # pick a nightly release from: https://github.com/foundry-rs/foundry/releases
          # version: "nightly-de33b6af53005037b463318d2628b5cfcaf39916"
          #version: "nightly-fdd321bac95f0935529164a88faf99d4d5cfa321"
          version: "v1.2.3"

      # Verify the correct Web3.py version is installed
      # This helps debug any remaining issues
      - name: Verify Web3.py version and environment isolation
        run: |
          echo "=== Environment Information ==="
          poetry env info
          echo ""
          echo "=== Python Version ==="
          poetry run python --version
          echo ""
          echo "=== Web3.py Version ==="
          poetry run python -c "import web3; print(f'Web3.py version: {web3.__version__}')"
          echo ""
          echo "=== Installed Packages (Web3-related) ==="
          poetry run python -c "
          import pkg_resources
          web3_packages = [pkg for pkg in pkg_resources.working_set if 'web3' in pkg.project_name.lower() or 'eth' in pkg.project_name.lower()]
          for pkg in sorted(web3_packages, key=lambda x: x.project_name):
              print(f'{pkg.project_name}: {pkg.version}')
          "

      # ============================================================================
      # GMX TEST EXECUTION - PARALLEL MODE (WITH WARNINGS)
      # ============================================================================
      # 
      # NOTE: Currently running in parallel mode, but be aware of potential issues:
      # GMX tests MAY have issues when running in parallel (with -n auto) because:
      # 
      # 1. MAINNET FORK RACE CONDITIONS:
      #    - GMX tests use mainnet forks via Anvil which share state
      #    - Parallel execution causes race conditions when multiple tests try to:
      #      * Deploy mock oracle contracts simultaneously
      #      * Execute orders on the same fork instance
      #      * Modify shared fork state (prices, timestamps, etc.)
      #    - This results in intermittent failures like:
      #      * "Transaction reverted" errors
      #      * Price validation failures (100 price validation checks)
      #      * Block timestamp conflicts
      # 
      # 2. OFF-CHAIN KEEPER DEPENDENCIES:
      #    - GMX uses off-chain keepers to execute orders
      #    - Order flow: User submits -> Protocol validates -> Keepers execute
      #    - In fork environments, we simulate keeper execution manually
      #    - Parallel tests can interfere with order execution timing
      #    - Tests may see orders in wrong states (pending vs executed)
      # 
      # 3. PRICE ORACLE MOCKING ISSUES:
      #    - Tests deploy MockOracleProvider to bypass price validations
      #    - Multiple tests deploying mocks simultaneously can cause:
      #      * Address conflicts
      #      * Price feed overwrites
      #      * Timestamp adjustment failures
      #    - The shouldAdjustTimestamp and isChainlinkOnChainProvider checks fail
      #      when multiple tests run concurrently
      # 
      # 4. BLOCK MINING CONFLICTS:
      #    - forge test doesn't mine blocks (for ease of testing)
      #    - anvil is different and mines blocks as tests run
      #    - Parallel tests cause:
      #      * Block number conflicts
      #      * Timestamp desynchronization
      #      * Price updates at wrong times
      #    - As new blocks are mined, prices differ and trigger validation failures
      # 
      # 5. EXECUTION BUFFER TIMING:
      #    - Tests use execution_buffer to wait for order execution
      #    - Parallel execution makes timing unpredictable
      #    - Orders may execute before/after expected times
      #    - Position verification fails due to timing issues
      # 
      # 6. SHARED FIXTURE STATE:
      #    - conftest.py creates shared fixtures (web3_arbitrum_fork, etc.)
      #    - These fixtures maintain state across tests
      #    - Parallel execution corrupts this shared state
      #    - Tests see data from other tests running simultaneously
      # 
      # 7. RPC ENDPOINT LIMITATIONS:
      #    - Fork tests require stable RPC endpoints
      #    - Parallel tests can overwhelm RPC rate limits
      #    - This causes connection timeouts and test failures
      #    - Serial execution reduces RPC load
      # 
      # 8. WHAT DOESN'T WORK IN PARALLEL:
      #    - test_trading.py: All position opening/closing tests fail due to fork state conflicts
      #    - test_ccxt_trading.py: CCXT integration tests fail with order execution timing issues
      #    - test_swap_order.py: Swap order tests fail due to price oracle conflicts
      #    - test_order.py: Base order tests fail with state corruption
      #    - test_open_positions.py: Position queries return wrong data from parallel tests
      #    - test_funding_fee.py: Funding fee calculations use wrong block numbers
      #    - test_gmx_oracle.py: Oracle price feeds get overwritten by parallel tests
      #    - test_pool_tvl.py: TVL calculations see inconsistent state
      #    - test_available_liquidity.py: Liquidity queries fail due to concurrent modifications
      #    - test_borrow_apr.py: APR calculations use stale data
      #    - test_claimable_fees.py: Fee claims see wrong positions
      #    - All CCXT tests in tests/gmx/ccxt/: Fail due to shared exchange instance state
      # 
      # 9. KNOWN WORKAROUNDS THAT DON'T WORK:
      #    - Using pytest-xdist with --dist=loadscope: Still causes fork state conflicts
      #    - Using separate fork instances per test: Too slow and resource intensive
      #    - Using locks/mutexes: Doesn't help with RPC-level race conditions
      #    - Using test isolation fixtures: Can't isolate fork state properly
      #    - Using separate RPC endpoints: Doesn't solve block/timestamp conflicts
      # 
      # 10. FUTURE FIXES NEEDED:
      #     - Implement proper fork isolation per test (if possible)
      #     - Create separate Anvil instances for each test (resource intensive)
      #     - Mock keeper execution more reliably
      #     - Fix price oracle mocking to be thread-safe
      #     - Implement proper test ordering/dependencies
      #     - Add retry logic for flaky tests
      #     - Consider using Tenderly forks instead of Anvil (more stable but slower)
      # 
      # ============================================================================
      # NOTE: Running in parallel mode, but be aware of the issues documented above.
      # If tests fail intermittently, consider switching back to serial execution.
      # ============================================================================
      - name: Run GMX tests (PARALLEL)
        run: |
          # WARNING: Running GMX tests in parallel may cause issues documented above.
          # If you see intermittent failures related to fork state, price validation,
          # or order execution timing, consider running serially by removing -n auto
          # 
          # Enable verbose output if debugging is enabled
          if [ "$ENABLE_VERBOSE_LOGGING" = "true" ]; then
            poetry run pytest tests/gmx/ --timeout-method=thread --tb=native -n auto -v -s --capture=no
          else
            # Run in parallel with verbose output to see which tests fail
            # Using -n auto for parallel execution, -v for verbose, --tb=short for cleaner output
            poetry run pytest tests/gmx/ --timeout-method=thread --tb=short -n auto
          fi
        env:
          # Arbitrum mainnet RPC is required for GMX tests (GMX is on Arbitrum)
          # Used for mainnet fork testing in conftest.py
          JSON_RPC_ARBITRUM: ${{ secrets.JSON_RPC_ARBITRUM }}
          # Arbitrum Sepolia testnet RPC for testnet GMX tests
          # Used for testnet integration tests
          ARBITRUM_SEPOLIA_RPC_URL: ${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}
          # Private key for GMX test transactions on Arbitrum Sepolia testnet
          # Required for testnet tests that need to submit transactions
          ARBITRUM_GMX_TEST_SEPOLIA_PRIVATE_KEY: ${{ secrets.ARBITRUM_GMX_TEST_SEPOLIA_PRIVATE_KEY }}
          # Enable verbose logging for debugging (set to "true" to enable)
          ENABLE_VERBOSE_LOGGING: "false"

      # NOTE: We don't run linting here as it's already done in the main workflow
      # Ruff lint check is only needed once per PR, not per test suite

