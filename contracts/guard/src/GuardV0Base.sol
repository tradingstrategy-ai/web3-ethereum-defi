/**
 * Check for legit trade execution actions.
 *
 * Function selector constants
 * ---------------------------
 *
 * To avoid runtime keccak256 computation, function selectors are pre-computed
 * as compile-time constants. To regenerate these constants, run:
 *
 *   cd contracts/guard && forge script script/ComputeSelectors.s.sol
 *
 */

pragma solidity ^0.8.0;

import "./lib/Path.sol";
import "./IGuard.sol";

import "./lib/IERC4626.sol";
import "./lib/IERC20.sol";
import "./lib/Multicall.sol";
import "./lib/SwapCowSwap.sol";

// Pre-computed function selectors to avoid runtime keccak256
// Generated by: forge script script/ComputeSelectors.s.sol

// ERC-20
bytes4 constant SEL_TRANSFER = 0xa9059cbb;  // transfer(address,uint256)
bytes4 constant SEL_APPROVE = 0x095ea7b3;  // approve(address,uint256)
bytes4 constant SEL_APPROVE_DELEGATION = 0xc04a8a10;  // approveDelegation(address,uint256)

// Uniswap V2
bytes4 constant SEL_SWAP_EXACT_TOKENS = 0x38ed1739;  // swapExactTokensForTokens(uint256,uint256,address[],address,uint256)
bytes4 constant SEL_SWAP_EXACT_TOKENS_FEE = 0x5c11d795;  // swapExactTokensForTokensSupportingFeeOnTransferTokens(...)

// Uniswap V3
bytes4 constant SEL_EXACT_INPUT = 0xc04b8d59;  // exactInput((bytes,address,uint256,uint256,uint256))
bytes4 constant SEL_EXACT_OUTPUT = 0xf28c0498;  // exactOutput((bytes,address,uint256,uint256,uint256))
bytes4 constant SEL_EXACT_INPUT_ROUTER02 = 0xb858183f;  // SwapRouter02 exactInput

// Aave V3
bytes4 constant SEL_AAVE_SUPPLY = 0x617ba037;  // supply(address,uint256,address,uint16)
bytes4 constant SEL_AAVE_WITHDRAW = 0x69328dec;  // withdraw(address,uint256,address)

// Lagoon
bytes4 constant SEL_SETTLE_DEPOSIT = 0x559ec80d;  // settleDeposit()
bytes4 constant SEL_SETTLE_REDEEM = 0xa03d55e3;  // settleRedeem()
bytes4 constant SEL_SETTLE_DEPOSIT_UINT = 0xd24ca58a;  // settleDeposit(uint256)
bytes4 constant SEL_SETTLE_REDEEM_UINT = 0xa627df66;  // settleRedeem(uint256)

// ERC-4626
bytes4 constant SEL_DEPOSIT = 0x6e553f65;  // deposit(uint256,address)
bytes4 constant SEL_WITHDRAW = 0xb460af94;  // withdraw(uint256,address,address)
bytes4 constant SEL_REDEEM = 0xba087652;  // redeem(uint256,address,address)

// ERC-4626 Umami non-standard
bytes4 constant SEL_DEPOSIT_UMAMI = 0x8dbdbe6d;  // deposit(uint256,uint256,address)
bytes4 constant SEL_REDEEM_UMAMI = 0x0169a996;  // redeem(uint256,uint256,address,address)

// ERC-7540
bytes4 constant SEL_DEPOSIT_7540 = 0x2e2d2984;  // deposit(uint256,address,address)
bytes4 constant SEL_REQUEST_REDEEM = 0x7d41c86e;  // requestRedeem(uint256,address,address)
bytes4 constant SEL_REQUEST_WITHDRAW = 0x32f25a3a;  // requestWithdraw(uint256,address,address)
bytes4 constant SEL_REQUEST_DEPOSIT = 0x85b77f45;  // requestDeposit(uint256,address,address)

// Gains/Ostium
bytes4 constant SEL_MAKE_WITHDRAW_REQUEST = 0xa8abe905;  // makeWithdrawRequest(uint256,address)

// Orderly
bytes4 constant SEL_DELEGATE_SIGNER = 0x2df4869b;  // delegateSigner((bytes32,address))
bytes4 constant SEL_ORDERLY_DEPOSIT = 0x322dda6d;  // deposit((bytes32,bytes32,bytes32,uint128))
bytes4 constant SEL_ORDERLY_WITHDRAW = 0x98c2d086;  // withdraw((bytes32,bytes32,bytes32,uint128,uint128,address,address,uint64))

// GMX
bytes4 constant SEL_GMX_MULTICALL = 0xac9650d8;  // multicall(bytes[])
bytes4 constant SEL_GMX_SEND_WNT = 0x7d39aaf1;  // sendWnt(address,uint256)
bytes4 constant SEL_GMX_SEND_TOKENS = 0xe6d66ac8;  // sendTokens(address,address,uint256)
bytes4 constant SEL_GMX_CREATE_ORDER = 0x296ea41f;  // createOrder(tuple) - hardcoded

/**
 * Prototype guard implementation.
 *
 * - Hardcoded actions for Uniswap v2, v3, Aave, etc.
 *
 * - Abstract base contract to deal with different ownership modifiers and initialisers (Safe, OpenZeppelin).
 *
 * - We include native multicall support so you can whitelist multiple assets in the same tx
 *
 */
abstract contract GuardV0Base is IGuard,  Multicall, SwapCowSwap  {

    using Path for bytes;
    using BytesLib for bytes;

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    // Allowed external smart contract calls (address, function selector) tuples
    mapping(address target => mapping(bytes4 selector => bool allowed)) public allowedCallSites;

    // Because of EVM limitations, maintain a separate list of allowed target smart contracts,
    // so we can produce better error messages.
    // Note: This list is only referential, as because EVM and Solidity are such crap,
    // it is not possible to smartly remove items from this list.
    // It is not used in the security checks.
    mapping(address target => bool allowed) public allowedTargets;

    // How many call sites we have enabled all-time counter.
    //
    // Used for diagnostics/debugging.
    //
    uint public callSiteCount;

    // Allowed ERC-20 tokens we may receive or send in a trade
    mapping(address token => bool allowed) public allowedAssets;

    // Allowed trade executor hot wallets
    mapping(address sender => bool allowed) public allowedSenders;

    // Allowed token receivers post trade
    mapping(address receiver => bool allowed) public allowedReceivers;

    // Allowed owners
    mapping(address destination => bool allowed) public allowedWithdrawDestinations;

    // Allowed routers
    mapping(address destination => bool allowed) public allowedApprovalDestinations;

    // Allowed delegation approval destinations
    mapping(address destination => bool allowed) public allowedDelegationApprovalDestinations;

    // Allowed Lagoon vault settlement destinations
    //
    // We need to perform this action as a Safe multisig by calling Vault.settleDeposit() and Vault.settleRedeem()
    //
    mapping(address destination => bool allowed) public allowedLagoonVaults;

    // Allowed cow swap instances.
    //
    // The deployed address of GPv2 settlement contract.
    //
    // https://etherscan.io/address/0x9008d19f58aabd9ed0d60971565aa8510560ab41
    //
    mapping(address destination => bool allowed) public allowedCowSwaps;

    // Allowed Velora (ParaSwap) Augustus Swapper instances.
    //
    // Augustus Swapper is the main router contract for Velora/ParaSwap.
    // TokenTransferProxy is whitelisted separately via allowApprovalDestination.
    //
    mapping(address destination => bool allowed) public allowedVeloraSwappers;

    // Allowed GMX Exchange Router instances.
    //
    // GMX uses multicall() on ExchangeRouter to batch order operations.
    // SyntheticsRouter is whitelisted separately via allowApprovalDestination for collateral.
    //
    mapping(address destination => bool allowed) public allowedGMXRouters;

    // GMX OrderVault addresses per ExchangeRouter.
    //
    // OrderVault is where tokens are sent before order execution via sendWnt/sendTokens.
    // We validate that tokens are only sent to the correct OrderVault.
    //
    mapping(address exchangeRouter => address orderVault) public gmxOrderVaults;

    // Allowed GMX markets (market contract addresses).
    //
    // Each GMX market is a separate contract. We can whitelist specific markets
    // to restrict which assets can be traded, or set anyAsset=true to allow all.
    //
    mapping(address market => bool allowed) public allowedGMXMarkets;

    // Allow trading any token
    //
    // Dangerous, as malicious/compromised trade-executor can drain all assets through creating fake tokens
    //
    bool public anyAsset;

    event CallSiteApproved(address target, bytes4 selector, string notes);
    event CallSiteRemoved(address target, bytes4 selector, string notes);

    event SenderApproved(address sender, string notes);
    event SenderRemoved(address sender, string notes);

    event ReceiverApproved(address sender, string notes);
    event ReceiverRemoved(address sender, string notes);

    event WithdrawDestinationApproved(address sender, string notes);
    event WithdrawDestinationRemoved(address sender, string notes);

    event ApprovalDestinationApproved(address sender, string notes);
    event ApprovalDestinationRemoved(address sender, string notes);

    event DelegationApprovalDestinationApproved(address sender, string notes);
    event DelegationApprovalDestinationRemoved(address sender, string notes);

    event AssetApproved(address sender, string notes);
    event AssetRemoved(address sender, string notes);

    event AnyAssetSet(bool value, string notes);
    event AnyVaultSet(bool value, string notes);


    event LagoonVaultApproved(address vault, string notes);

    event CowSwapApproved(address settlementContract, string notes);
    event VeloraSwapperApproved(address augustusSwapper, string notes);
    event GMXRouterApproved(address exchangeRouter, address syntheticsRouter, string notes);
    event GMXMarketApproved(address market, string notes);
    event GMXMarketRemoved(address market, string notes);
    event ERC4626Approved(address vault, string notes);

    // Velora swap execution event - emitted after successful atomic swap
    event VeloraSwapExecuted(
        uint256 indexed timestamp,
        address indexed augustusSwapper,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 minAmountOut
    );

    // Implementation needs to provide its own ownership policy hooks
    modifier onlyGuardOwner() virtual;

    // Implementation needs to provide its own ownership policy hooks
    function getGovernanceAddress() virtual public view returns (address);

    /**
     * Calculate Solidity 4-byte function selector from a string.
     */
    function getSelector(string memory _func) internal pure returns (bytes4) {
        // https://solidity-by-example.org/function-selector/
        return bytes4(keccak256(bytes(_func)));
    }

    /**
     * Track version during internal development.
     *
     * We bump up when new whitelistings added.
     */
    function getInternalVersion() public pure returns (uint8) {
        return 1;
    }

    function allowCallSite(address target, bytes4 selector, string calldata notes) public onlyGuardOwner {
        allowedCallSites[target][selector] = true;
        allowedTargets[target] = true;
        callSiteCount++;
        emit CallSiteApproved(target, selector, notes);
    }

    function removeCallSite(address target, bytes4 selector, string calldata notes) public onlyGuardOwner {
        delete allowedCallSites[target][selector];
        emit CallSiteRemoved(target, selector, notes);
    }

    function allowSender(address sender, string calldata notes) public onlyGuardOwner {
        allowedSenders[sender] = true;
        emit SenderApproved(sender, notes);
    }

    function removeSender(address sender, string calldata notes) public onlyGuardOwner {
        delete allowedSenders[sender];
        emit SenderRemoved(sender, notes);
    }

    function allowReceiver(address receiver, string calldata notes) public onlyGuardOwner {
        allowedReceivers[receiver] = true;
        emit ReceiverApproved(receiver, notes);
    }

    function removeReceiver(address receiver, string calldata notes) public onlyGuardOwner {
        delete allowedReceivers[receiver];
        emit ReceiverRemoved(receiver, notes);
    }

    function allowWithdrawDestination(address destination, string calldata notes) public onlyGuardOwner {
        allowedWithdrawDestinations[destination] = true;
        emit WithdrawDestinationApproved(destination, notes);
    }

    function removeWithdrawDestination(address destination, string calldata notes) public onlyGuardOwner {
        delete allowedWithdrawDestinations[destination];
        emit WithdrawDestinationRemoved(destination, notes);
    }

    function allowApprovalDestination(address destination, string calldata notes) public onlyGuardOwner {
        allowedApprovalDestinations[destination] = true;
        emit ApprovalDestinationApproved(destination, notes);
    }

    function removeApprovalDestination(address destination, string calldata notes) public onlyGuardOwner {
        delete allowedApprovalDestinations[destination];
        emit ApprovalDestinationRemoved(destination, notes);
    }

    function allowDelegationApprovalDestination(address destination, string calldata notes) public onlyGuardOwner {
        allowedDelegationApprovalDestinations[destination] = true;
        emit ApprovalDestinationApproved(destination, notes);
    }

    function removeDelegationApprovalDestination(address destination, string calldata notes) public onlyGuardOwner {
        delete allowedApprovalDestinations[destination];
        emit ApprovalDestinationRemoved(destination, notes);
    }

    function allowAsset(address asset, string calldata notes) public onlyGuardOwner {
        allowedAssets[asset] = true;
        emit AssetApproved(asset, notes);
    }

    function removeAsset(address asset, string calldata notes) public onlyGuardOwner {
        delete allowedAssets[asset];
        emit AssetRemoved(asset, notes);
    }

    function whitelistLagoon(address vault, string calldata notes) public onlyGuardOwner {
        allowedLagoonVaults[vault] = true;
        allowCallSite(vault, SEL_SETTLE_DEPOSIT, notes);
        allowCallSite(vault, SEL_SETTLE_REDEEM, notes);
        // Lagoon v0.5.0+
        allowCallSite(vault, SEL_SETTLE_DEPOSIT_UINT, notes);
        allowCallSite(vault, SEL_SETTLE_REDEEM_UINT, notes);
        emit LagoonVaultApproved(vault, notes);
    }

    function isAnyTokenApproveSelector(bytes4 selector) internal pure returns (bool) {
        return selector == SEL_APPROVE;
    }

    // Basic check if any target contract is whitelisted
    function isAllowedCallSite(address target, bytes4 selector) public view returns (bool) {
        return allowedCallSites[target][selector];
    }

    function isAllowedTarget(address target) public view returns (bool) {
        return allowedTargets[target] == true;
    }

    function isAllowedSender(address sender) public view returns (bool) {
        return allowedSenders[sender] == true;
    }

    // Assume any tokens are send back to the vault
    function isAllowedReceiver(address receiver) public view returns (bool) {
        return allowedReceivers[receiver] == true;
    }

    function isAllowedWithdrawDestination(address receiver) public view returns (bool) {
        return allowedWithdrawDestinations[receiver] == true;
    }

    function isAllowedApprovalDestination(address receiver) public view returns (bool) {
        return allowedApprovalDestinations[receiver] == true;
    }

    function isAllowedDelegationApprovalDestination(address receiver) public view returns (bool) {
        return allowedDelegationApprovalDestinations[receiver] == true;
    }

    /**
     * Are we allowed to trade/own an ERC-20.
     */
    function isAllowedAsset(address token) public view returns (bool) {
        return anyAsset || allowedAssets[token] == true;
    }

    function isAllowedLagoonVault(address vault) public view returns (bool) {
        return allowedLagoonVaults[vault] == true;
    }

    function isAllowedCowSwap(address settlement) public view returns (bool) {
        return allowedCowSwaps[settlement] == true;
    }

    function isAllowedVeloraSwapper(address swapper) public view returns (bool) {
        return allowedVeloraSwappers[swapper] == true;
    }

    function validate_transfer(bytes memory callData) public view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(isAllowedWithdrawDestination(to), "Receiver not whitelisted");
    }

    function validate_approve(bytes memory callData) public view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(isAllowedApprovalDestination(to), "Approve address not allowed");
    }

    function validate_approveDelegation(bytes memory callData) public view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(isAllowedDelegationApprovalDestination(to), "Delegation address not allowed");
    }

    // Make this callable both internally and externally
    function _whitelistToken(address token, string calldata notes) internal {
        allowCallSite(token, SEL_TRANSFER, notes);
        allowCallSite(token, SEL_APPROVE, notes);
        allowAsset(token, notes);
    }

    // Allow ERC-20.approve() to a specific asset and this asset used as the part of path of swaps
    function whitelistToken(address token, string calldata notes) external {
        _whitelistToken(token, notes);
    }

    function whitelistTokenForDelegation(address token, string calldata notes) external {
        allowCallSite(token, SEL_APPROVE_DELEGATION, notes);
        allowAsset(token, notes);
    }

    // Whitelist SwapRouter or SwapRouter02
    function whitelistUniswapV3Router(address router, string calldata notes) external {
        allowCallSite(router, SEL_EXACT_INPUT, notes);
        allowCallSite(router, SEL_EXACT_OUTPUT, notes);
        allowCallSite(router, SEL_EXACT_INPUT_ROUTER02, notes);
        allowApprovalDestination(router, notes);
    }

    function whitelistUniswapV2Router(address router, string calldata notes) external {
        allowCallSite(router, SEL_SWAP_EXACT_TOKENS, notes);
        allowCallSite(router, SEL_SWAP_EXACT_TOKENS_FEE, notes);
        allowApprovalDestination(router, notes);
    }

    // Enable unlimited trading space
    function setAnyAssetAllowed(bool value, string calldata notes) external onlyGuardOwner {
        anyAsset = value;
        emit AnyAssetSet(value, notes);
    }

    // Satisfy IGuard
    function validateCall(
        address sender,
        address target,
        bytes calldata callDataWithSelector
    ) external view {
        _validateCallInternal(sender, target, callDataWithSelector);
    }

    function _validateCallInternal(
        address sender,
        address target,
        bytes calldata callDataWithSelector
    ) internal view {

        // Governance can always perform any action through guard
        if(sender == getGovernanceAddress()) {
            return;
        }

        // Assume sender is trade-executor hot wallet
        require(isAllowedSender(sender), "Sender not allowed");

        bytes4 selector = bytes4(callDataWithSelector[:4]);
        bytes calldata callData = callDataWithSelector[4:];

        // If we have dynamic whitelist/any token, we cannot check approve() call sites of
        // individual tokens
        bool anyTokenCheck = anyAsset && isAnyTokenApproveSelector(selector);

        // With anyToken, we cannot check approve() call site because we do not whitelist
        // individual token addresses
        if(!anyTokenCheck) {
            if(!isAllowedCallSite(target, selector)) {
                require(isAllowedTarget(target), "Target not allowed");
                require(isAllowedCallSite(target, selector), "Selector not allowed");
            }
        }

        // Validate the function payload.
        // Depends on the called protocol.
        if(selector == SEL_SWAP_EXACT_TOKENS) {
            validate_swapExactTokensForTokens(callData);
        } else if(selector == SEL_SWAP_EXACT_TOKENS_FEE) {
            validate_swapExactTokensForTokens(callData);
        } else if(selector == SEL_EXACT_INPUT) {
            validate_exactInput(callData);
        } else if(selector == SEL_EXACT_INPUT_ROUTER02) {
            // See whitelistUniswapV3Router
            require(anyAsset, "SwapRouter02 requires anyAsset");
        } else if(selector == SEL_TRANSFER) {
            validate_transfer(callData);
        } else if(selector == SEL_APPROVE) {
            validate_approve(callData);
        } else if(selector == SEL_APPROVE_DELEGATION) {
            validate_approveDelegation(callData);
        } else if(selector == SEL_AAVE_SUPPLY) {
            validate_aaveSupply(callData);
        } else if(selector == SEL_AAVE_WITHDRAW) {
            validate_aaveWithdraw(callData);
        } else if (selector == SEL_SETTLE_DEPOSIT) {
            validate_lagoonSettle(target);
        } else if (selector == SEL_SETTLE_REDEEM) {
            validate_lagoonSettle(target);
        } else if (selector == SEL_SETTLE_DEPOSIT_UINT) {
            validate_lagoonSettle(target);
        } else if (selector == SEL_SETTLE_REDEEM_UINT) {
            validate_lagoonSettle(target);
        } else if (selector == SEL_DEPOSIT || selector == SEL_DEPOSIT_7540) {
            // Guard logic in approve() whitelist - no further checks here needed
        } else if (selector == SEL_DEPOSIT_UMAMI) {
            // Umami non-standard ERC-4626 deposit with minShares slippage parameter
            validate_UmamiDeposit(callData);
        } else if (selector == SEL_REDEEM_UMAMI) {
            // Umami non-standard ERC-4626 redeem with minShares slippage parameter
            validate_UmamiRedeem(callData);
        } else if (selector == SEL_WITHDRAW) {
            validate_ERC4626Withdraw(callData);
        } else if (selector == SEL_REDEEM) {
            validate_ERC4626Redeem(callData);
        } else if (selector == SEL_REQUEST_REDEEM) {
            // ERC-7540: same parameters as ERC-4626
            validate_ERC4626Redeem(callData);
        } else if (selector == SEL_REQUEST_WITHDRAW) {
            // ERC-7540: same parameters as ERC-4626
            validate_ERC4626Withdraw(callData);
        } else if (selector == SEL_REQUEST_DEPOSIT) {
            // Guard logic in approve() whitelist - no further checks here needed
        } else if (selector == SEL_MAKE_WITHDRAW_REQUEST) {
            // Gains/Ostium modified ERC-4626
        } else if (selector == SEL_DELEGATE_SIGNER) {
            validate_orderlyDelegateSigner(callData);
        } else if (selector == SEL_ORDERLY_DEPOSIT) {
            validate_orderlyDeposit(callData);
        } else if (selector == SEL_ORDERLY_WITHDRAW) {
            validate_orderlyWithdraw(callData);
        } else if (selector == SEL_GMX_MULTICALL) {
            // GMX multicall - validate inner calls
            validate_gmxMulticall(target, sender, callData);
        } else {
            revert("Unknown function selector");
        }
    }

    // Validate Uniswap v2 trade
    function validate_swapExactTokensForTokens(bytes memory callData) public view {
        (, , address[] memory path, address to, ) = abi.decode(callData, (uint, uint, address[], address, uint));
        require(isAllowedReceiver(to), "Receiver not whitelisted");
        address token;
        for (uint256 i = 0; i < path.length; i++) {
            token = path[i];
            require(isAllowedAsset(token), "Token not allowed");
        }
    }

    // Validate Uniswap v3 trade
    function validate_exactInput(bytes memory callData) public view {
        (ExactInputParams memory params) = abi.decode(callData, (ExactInputParams));
        require(isAllowedReceiver(params.recipient), "Receiver not whitelisted");
        validateUniswapV3Path(params.path);
    }

    function validate_exactOutput(bytes memory callData) public view {
        (ExactOutputParams memory params) = abi.decode(callData, (ExactOutputParams));
        require(isAllowedReceiver(params.recipient), "Receiver not whitelisted");
        validateUniswapV3Path(params.path);
    }

    function validateUniswapV3Path(bytes memory path) public view {
        address tokenIn;
        address tokenOut;
        while (true) {
            (tokenOut, tokenIn, ) = path.decodeFirstPool();
            require(isAllowedAsset(tokenIn), "Token not allowed");
            require(isAllowedAsset(tokenOut), "Token not allowed");
            if (path.hasMultiplePools()) {
                path = path.skipToken();
            } else {
                break;
            }
        }
    }


    // ERC-4626 trading: Check we are allowed to deposit to a vault
    function validate_ERC4626Deposit(address target, bytes memory callData) public view {
        // This is no-op.
        // As ERC-4626 deposits are basically controlled by approve() permission
    }

    // ERC-4626 trading: Check we are allowed to withdraw from a vault to ourselves only
    function validate_ERC4626Withdraw(bytes memory callData) public view {
        (, address receiver, ) = abi.decode(callData, (uint256, address, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // ERC-4626 trading: Check we are allowed to redeem from a vault to ourselves only
    function validate_ERC4626Redeem(bytes memory callData) public view {
        (, address receiver, ) = abi.decode(callData, (uint256, address, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // Umami non-standard ERC-4626 deposit
    function validate_UmamiDeposit(bytes memory callData) public view {
        (, , address receiver) = abi.decode(callData, (uint256, uint256, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // Umami non-standard ERC-4626 redeem
    function validate_UmamiRedeem(bytes memory callData) public view {
        (, , address receiver, ) = abi.decode(callData, (uint256, uint256, address, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // Validate cow swap settlement
    function validate_cowSwapSettlement(bytes memory callData) public view {
        (, address receiver, ) = abi.decode(callData, (uint256, address, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    /**
     * Whitelist an ERC-4626/ERC-7540 vault.
     *
     * - Callsites for deposits and redemptions
     * - Vault share and denomination tokens
     * - Any ERC-4626 extensions are not supported by this function, like special share tokens
     * - ERC-4626 withdrawal address must be always the Safe
     * - Because of non-standardisation the whitelisted function list is long
     */
    function whitelistERC4626(address vault, string calldata notes) external {
        IERC4626 vault_ = IERC4626(vault);
        address denominationToken = vault_.asset();
        address shareToken = vault;

        // ERC-4626
        allowCallSite(vault, SEL_DEPOSIT, notes);
        allowCallSite(vault, SEL_WITHDRAW, notes);
        allowCallSite(vault, SEL_REDEEM, notes);

        // Umami non-standard ERC-4626
        allowCallSite(vault, SEL_DEPOSIT_UMAMI, notes);
        allowCallSite(vault, SEL_REDEEM_UMAMI, notes);

        // ERC-7540
        allowCallSite(vault, SEL_DEPOSIT_7540, notes);
        allowCallSite(vault, SEL_REQUEST_REDEEM, notes);
        allowCallSite(vault, SEL_REQUEST_WITHDRAW, notes);
        allowCallSite(vault, SEL_REQUEST_DEPOSIT, notes);

        // Ostium/Gains
        allowCallSite(vault, SEL_MAKE_WITHDRAW_REQUEST, notes);

        allowApprovalDestination(vault, notes);
        _whitelistToken(shareToken, notes);
        _whitelistToken(denominationToken, notes);

        emit ERC4626Approved(vault, notes);
    }

    // Aave V3 implementation
    function validate_aaveSupply(bytes memory callData) public view {
        (address token, , , ) = abi.decode(callData, (address, uint, address, uint));
        require(isAllowedAsset(token), "Token not allowed");
    }

    function validate_aaveWithdraw(bytes memory callData) public view {
        (address token, , address to) = abi.decode(callData, (address, uint, address));
        require(isAllowedAsset(token), "Token not allowed");
        require(isAllowedReceiver(to), "Receiver not whitelisted");
    }

    function whitelistAaveV3(address lendingPool, string calldata notes) external {
        allowCallSite(lendingPool, SEL_AAVE_SUPPLY, notes);
        allowCallSite(lendingPool, SEL_AAVE_WITHDRAW, notes);
        allowApprovalDestination(lendingPool, notes);
    }

    function validate_lagoonSettle(address vault) public view {
        require(isAllowedLagoonVault(vault), "Vault not allowed");
    }

    function whitelistOrderly(address orderlyVault, string calldata notes) external {
        allowCallSite(orderlyVault, SEL_DELEGATE_SIGNER, notes);
        allowCallSite(orderlyVault, SEL_ORDERLY_DEPOSIT, notes);
        allowCallSite(orderlyVault, SEL_ORDERLY_WITHDRAW, notes);
        allowApprovalDestination(orderlyVault, notes);
    }

    // https://github.com/cowprotocol/contracts/tree/main/deployments
    function whitelistCowSwap(address settlementContract, address relayerContract, string calldata notes) external {
        // Interaction by special _swapAndValidateCowSwap() internal function
        allowApprovalDestination(settlementContract, notes);
        allowApprovalDestination(relayerContract, notes);
        allowedCowSwaps[settlementContract] = true;
        emit CowSwapApproved(settlementContract, notes);
    }

    // Whitelist Velora (ParaSwap) Augustus Swapper for atomic swaps.
    //
    // TokenTransferProxy must be approved for token spending (not Augustus).
    // See: https://developers.velora.xyz
    //
    function whitelistVelora(address augustusSwapper, address tokenTransferProxy, string calldata notes) external onlyGuardOwner {
        allowApprovalDestination(tokenTransferProxy, notes);
        allowedVeloraSwappers[augustusSwapper] = true;
        emit VeloraSwapperApproved(augustusSwapper, notes);
    }

    // Whitelist GMX Exchange Router for perpetuals trading.
    //
    // GMX uses multicall() on ExchangeRouter to batch: sendWnt, sendTokens, createOrder.
    // SyntheticsRouter must be approved for collateral token spending.
    // OrderVault is where tokens are sent before order execution.
    // See: https://docs.gmx.io
    //
    function whitelistGMX(
        address exchangeRouter,
        address syntheticsRouter,
        address orderVault,
        string calldata notes
    ) external onlyGuardOwner {
        // Allow multicall on ExchangeRouter
        allowCallSite(exchangeRouter, SEL_GMX_MULTICALL, notes);
        // Allow token approvals to SyntheticsRouter for collateral
        allowApprovalDestination(syntheticsRouter, notes);
        // Store orderVault for receiver validation in sendWnt/sendTokens
        gmxOrderVaults[exchangeRouter] = orderVault;
        // Track allowed routers
        allowedGMXRouters[exchangeRouter] = true;
        emit GMXRouterApproved(exchangeRouter, syntheticsRouter, notes);
    }

    function isAllowedGMXRouter(address router) public view returns (bool) {
        return allowedGMXRouters[router];
    }

    // Whitelist a GMX market for trading.
    //
    // Markets are specific trading pairs (e.g., ETH/USD, BTC/USD).
    // If anyAsset is set, all markets are allowed.
    //
    function whitelistGMXMarket(address market, string calldata notes) external onlyGuardOwner {
        allowedGMXMarkets[market] = true;
        emit GMXMarketApproved(market, notes);
    }

    function removeGMXMarket(address market, string calldata notes) external onlyGuardOwner {
        allowedGMXMarkets[market] = false;
        emit GMXMarketRemoved(market, notes);
    }

    function isAllowedGMXMarket(address market) public view returns (bool) {
        return anyAsset || allowedGMXMarkets[market];
    }

    // Validate a GMX multicall payload.
    //
    // Decodes the multicall bytes[] and validates each inner call:
    // - sendWnt: receiver must be orderVault
    // - sendTokens: token must be allowed, receiver must be orderVault
    // - createOrder: receiver/cancellationReceiver must be Safe, market/collateral must be allowed
    //
    function validate_gmxMulticall(
        address exchangeRouter,
        address safeAddress,
        bytes calldata callData
    ) public view {
        require(isAllowedGMXRouter(exchangeRouter), "GMX router not allowed");

        address orderVault = gmxOrderVaults[exchangeRouter];
        require(orderVault != address(0), "GMX orderVault not configured");

        // Decode multicall bytes array
        bytes[] memory calls = abi.decode(callData, (bytes[]));

        for (uint256 i = 0; i < calls.length; i++) {
            require(calls[i].length >= 4, "GMX: call too short");
            bytes4 selector = bytes4(calls[i][0]) | (bytes4(calls[i][1]) >> 8) | (bytes4(calls[i][2]) >> 16) | (bytes4(calls[i][3]) >> 24);
            bytes memory innerCallData = _sliceBytes(calls[i], 4, calls[i].length - 4);

            if (selector == SEL_GMX_SEND_WNT) {
                _validate_gmxSendWnt(innerCallData, orderVault);
            } else if (selector == SEL_GMX_SEND_TOKENS) {
                _validate_gmxSendTokens(innerCallData, orderVault);
            } else if (selector == SEL_GMX_CREATE_ORDER) {
                _validate_gmxCreateOrder(innerCallData, safeAddress);
            } else {
                revert("GMX: Unknown function in multicall");
            }
        }
    }

    function _sliceBytes(bytes memory data, uint256 start, uint256 length) internal pure returns (bytes memory) {
        bytes memory result = new bytes(length);
        for (uint256 i = 0; i < length; i++) {
            result[i] = data[start + i];
        }
        return result;
    }

    function _validate_gmxSendWnt(bytes memory callData, address orderVault) internal pure {
        (address receiver, ) = abi.decode(callData, (address, uint256));
        require(receiver == orderVault, "GMX sendWnt: invalid receiver");
    }

    function _validate_gmxSendTokens(bytes memory callData, address orderVault) internal view {
        (address token, address receiver, ) = abi.decode(callData, (address, address, uint256));
        require(receiver == orderVault, "GMX sendTokens: invalid receiver");
        require(isAllowedAsset(token), "GMX sendTokens: token not allowed");
    }

    function _validate_gmxCreateOrder(bytes memory callData, address safeAddress) internal view {
        // Minimal decode - only extract fields we need to validate
        // CreateOrderParams is a nested tuple with addresses at the start:
        // Offset 0x00: receiver
        // Offset 0x20: cancellationReceiver
        // Offset 0x40: callbackContract (skip)
        // Offset 0x60: uiFeeReceiver (skip)
        // Offset 0x80: market
        // Offset 0xa0: initialCollateralToken

        address receiver;
        address cancellationReceiver;
        address market;
        address initialCollateralToken;

        assembly {
            let dataPtr := add(callData, 32) // Skip length prefix
            receiver := mload(dataPtr)
            cancellationReceiver := mload(add(dataPtr, 0x20))
            market := mload(add(dataPtr, 0x80))
            initialCollateralToken := mload(add(dataPtr, 0xa0))
        }

        // Validate receiver addresses - must be Safe only
        require(receiver == safeAddress, "GMX createOrder: receiver must be Safe");
        require(cancellationReceiver == safeAddress, "GMX createOrder: cancellationReceiver must be Safe");

        // Validate market (unless anyAsset is set)
        require(isAllowedGMXMarket(market), "GMX createOrder: market not allowed");

        // Validate collateral token (unless anyAsset is set)
        require(isAllowedAsset(initialCollateralToken), "GMX createOrder: collateral not allowed");
    }

    // Validate Velora swap and compute pre-swap balance
    //
    // Returns the pre-swap balance of tokenOut for slippage verification
    //
    function _validateVeloraSwapAndGetPreBalance(
        address safeAddress,
        address augustusSwapper,
        address tokenIn,
        address tokenOut
    ) internal view returns (uint256) {
        require(isAllowedVeloraSwapper(augustusSwapper), "Velora swapper not enabled");
        require(isAllowedSender(msg.sender), "Sender not allowed");
        require(isAllowedAsset(tokenIn), "tokenIn not allowed");
        require(isAllowedAsset(tokenOut), "tokenOut not allowed");
        return IERC20(tokenOut).balanceOf(safeAddress);
    }

    // Verify slippage after Velora swap execution and emit event
    //
    // Call this after executing the swap calldata on the Safe
    //
    function _verifyVeloraSwapAndEmit(
        address safeAddress,
        address augustusSwapper,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 preBalance
    ) internal {
        uint256 postBalance = IERC20(tokenOut).balanceOf(safeAddress);
        require(postBalance >= preBalance + minAmountOut, "Insufficient output amount");

        emit VeloraSwapExecuted(
            block.timestamp,
            augustusSwapper,
            tokenIn,
            tokenOut,
            amountIn,
            postBalance - preBalance,
            minAmountOut
        );
    }

    /**
     * Swap and validate a CowSwap order.
     *
     * Checks that an asset manager tries to perform a legit CowSwap swap.
     *
     * 1. Validate the swap is within our allowed whitelists
     * 2. Create a Order structure
     * 3. Calculate order data hash and prefix with additional information to create order UID
     * 4. Set up data needed to call ICowSettlement.setPreSignature(orderUid, True) from Gnosis Safe as a
     * 5. Return data to call setPreSignature(orderUid, True) on CowSwap by Safe
     * 6. Offchain logic can now take over to fill the order
     *     6.a) Read the emitted order data from OrderSigned event
     *     6.b) Submit to CowSwap offchain settlement system
     *     6.c) Wait for order to be filled
     *
     * Assume receiver is the same as owner that is the same as the Gnosis Safe address.
     */
    function _swapAndValidateCowSwap(
        address settlementContract,
        address receiver,
        bytes32 appData,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) internal returns (PresignDeletaCallData memory) {
        require(isAllowedCowSwap(settlementContract), "CowSwap not enabled");
        require(isAllowedSender(msg.sender), "Sender not allowed");
        require(isAllowedAsset(tokenIn), "tokenIn not allowed");
        require(isAllowedAsset(tokenOut), "tokenOut not allowed");
        require(isAllowedReceiver(receiver), "Receiver not allowed");
        GPv2Order.Data memory order = _createCowSwapOrder(
            appData,
            receiver,
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut
        );
        return _signCowSwapOrder(
            settlementContract,
            receiver,
            order
        );
    }

    function validate_orderlyDelegateSigner(bytes memory callData) public view {
        // TODO: Implement validation
    }

    function validate_orderlyDeposit(bytes memory callData) public view {
        // TODO: Implement validation
    }

    function validate_orderlyWithdraw(bytes memory callData) public view {
        // TODO: Implement
    }

}