/**
 * Check for legit trade execution actions.
 *
 * Function selector constants
 * ---------------------------
 *
 * To avoid runtime keccak256 computation, function selectors are pre-computed
 * as compile-time constants. To regenerate these constants, run:
 *
 *   cd contracts/guard && forge script script/ComputeSelectors.s.sol
 *
 */

pragma solidity ^0.8.0;

import "./lib/Path.sol";
import "./IGuard.sol";

import "./lib/IERC4626.sol";
import "./lib/IERC20.sol";
import "./lib/Multicall.sol";
import {CowSwapLib, PresignCallData} from "./lib/CowSwapLib.sol";
import {GmxLib, SEL_GMX_MULTICALL} from "./lib/GmxLib.sol";
import {
    HypercoreVaultLib,
    SEL_SEND_RAW_ACTION,
    SEL_CORE_DEPOSIT
} from "./lib/HypercoreVaultLib.sol";

// Pre-computed function selectors to avoid runtime keccak256
// Generated by: forge script script/ComputeSelectors.s.sol

// ===== ERC-20 =====
bytes4 constant SEL_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
bytes4 constant SEL_APPROVE = 0x095ea7b3; // approve(address,uint256)
bytes4 constant SEL_APPROVE_DELEGATION = 0xc04a8a10; // approveDelegation(address,uint256)

// ===== Uniswap V2 =====
bytes4 constant SEL_SWAP_EXACT_TOKENS = 0x38ed1739; // swapExactTokensForTokens(uint256,uint256,address[],address,uint256)
bytes4 constant SEL_SWAP_EXACT_TOKENS_FEE = 0x5c11d795; // swapExactTokensForTokensSupportingFeeOnTransferTokens(...)

// ===== Uniswap V3 =====
bytes4 constant SEL_EXACT_INPUT = 0xc04b8d59; // exactInput((bytes,address,uint256,uint256,uint256))
bytes4 constant SEL_EXACT_OUTPUT = 0xf28c0498; // exactOutput((bytes,address,uint256,uint256,uint256))
bytes4 constant SEL_EXACT_INPUT_ROUTER02 = 0xb858183f; // SwapRouter02 exactInput

// ===== Aave V3 =====
bytes4 constant SEL_AAVE_SUPPLY = 0x617ba037; // supply(address,uint256,address,uint16)
bytes4 constant SEL_AAVE_WITHDRAW = 0x69328dec; // withdraw(address,uint256,address)

// ===== Lagoon =====
bytes4 constant SEL_SETTLE_DEPOSIT = 0x559ec80d; // settleDeposit()
bytes4 constant SEL_SETTLE_REDEEM = 0xa03d55e3; // settleRedeem()
bytes4 constant SEL_SETTLE_DEPOSIT_UINT = 0xd24ca58a; // settleDeposit(uint256)
bytes4 constant SEL_SETTLE_REDEEM_UINT = 0xa627df66; // settleRedeem(uint256)

// ===== ERC-4626 =====
bytes4 constant SEL_DEPOSIT = 0x6e553f65; // deposit(uint256,address)
bytes4 constant SEL_WITHDRAW = 0xb460af94; // withdraw(uint256,address,address)
bytes4 constant SEL_REDEEM = 0xba087652; // redeem(uint256,address,address)

// ===== ERC-4626 Umami (non-standard) =====
bytes4 constant SEL_DEPOSIT_UMAMI = 0x8dbdbe6d; // deposit(uint256,uint256,address)
bytes4 constant SEL_REDEEM_UMAMI = 0x0169a996; // redeem(uint256,uint256,address,address)

// ===== ERC-7540 =====
bytes4 constant SEL_DEPOSIT_7540 = 0x2e2d2984; // deposit(uint256,address,address)
bytes4 constant SEL_REQUEST_REDEEM = 0x7d41c86e; // requestRedeem(uint256,address,address)
bytes4 constant SEL_REQUEST_WITHDRAW = 0x32f25a3a; // requestWithdraw(uint256,address,address)
bytes4 constant SEL_REQUEST_DEPOSIT = 0x85b77f45; // requestDeposit(uint256,address,address)

// ===== Gains/Ostium =====
bytes4 constant SEL_MAKE_WITHDRAW_REQUEST = 0xa8abe905; // makeWithdrawRequest(uint256,address)

// ===== Orderly =====
bytes4 constant SEL_DELEGATE_SIGNER = 0x2df4869b; // delegateSigner((bytes32,address))
bytes4 constant SEL_ORDERLY_DEPOSIT = 0x322dda6d; // deposit((bytes32,bytes32,bytes32,uint128))
bytes4 constant SEL_ORDERLY_WITHDRAW = 0x98c2d086; // withdraw((bytes32,bytes32,bytes32,uint128,uint128,address,address,uint64))

// ===== CCTP V2 =====
bytes4 constant SEL_CCTP_DEPOSIT_FOR_BURN = 0x8e0250ee; // depositForBurn(uint256,uint32,bytes32,address,bytes32,uint256,uint32)

/**
 * Prototype guard implementation.
 *
 * - Hardcoded actions for Uniswap v2, v3, Aave, etc.
 *
 * - Abstract base contract to deal with different ownership modifiers and initialisers (Safe, OpenZeppelin).
 *
 * - We include native multicall support so you can whitelist multiple assets in the same tx
 *
 */
abstract contract GuardV0Base is IGuard, Multicall {
    using Path for bytes;
    using BytesLib for bytes;

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    // ========================================================================
    //                           STORAGE VARIABLES
    // ========================================================================

    // ----- Core access control -----

    // Allowed external smart contract calls (address, function selector) tuples
    mapping(address target => mapping(bytes4 selector => bool allowed))
        public allowedCallSites;

    // Because of EVM limitations, maintain a separate list of allowed target smart contracts,
    // so we can produce better error messages.
    // Note: This list is only referential, as because EVM and Solidity are such crap,
    // it is not possible to smartly remove items from this list.
    // It is not used in the security checks.
    mapping(address target => bool allowed) public allowedTargets;

    // How many call sites we have enabled all-time counter.
    //
    // Used for diagnostics/debugging.
    //
    uint public callSiteCount;

    // Allowed ERC-20 tokens we may receive or send in a trade
    mapping(address token => bool allowed) public allowedAssets;

    // Allowed trade executor hot wallets
    mapping(address sender => bool allowed) public allowedSenders;

    // Allowed token/fund receivers post trade.
    //
    // This whitelist controls which addresses can receive funds from trading operations.
    // Typically the Safe/vault address is added here to ensure funds flow back to the vault.
    //
    // Used by:
    // - Uniswap V2/V3 swaps: validates swap recipient
    // - Aave withdrawals: validates withdrawal recipient
    // - ERC-4626 withdrawals/redemptions: validates receiver
    // - GMX perpetuals: validates order receiver and cancellation receiver
    // - CowSwap: validates order receiver
    //
    // Call allowReceiver(address, notes) to whitelist an address.
    //
    mapping(address receiver => bool allowed) public allowedReceivers;

    // ----- Transfer destinations -----

    // Allowed owners
    mapping(address destination => bool allowed)
        public allowedWithdrawDestinations;

    // Allowed routers
    mapping(address destination => bool allowed)
        public allowedApprovalDestinations;

    // Allowed delegation approval destinations
    mapping(address destination => bool allowed)
        public allowedDelegationApprovalDestinations;

    // ----- Protocol: Lagoon -----

    // Allowed Lagoon vault settlement destinations
    //
    // We need to perform this action as a Safe multisig by calling Vault.settleDeposit() and Vault.settleRedeem()
    //
    mapping(address destination => bool allowed) public allowedLagoonVaults;

    // ----- Protocol: CowSwap -----
    // Storage is in CowSwapLib diamond storage (keccak256("eth_defi.cowswap.v1"))

    // ----- Protocol: Velora -----

    // Allowed Velora (ParaSwap) Augustus Swapper instances.
    //
    // Augustus Swapper is the main router contract for Velora/ParaSwap.
    // TokenTransferProxy is whitelisted separately via allowApprovalDestination.
    //
    mapping(address destination => bool allowed) public allowedVeloraSwappers;

    // ----- Protocol: GMX -----
    // Storage is in GmxLib diamond storage (keccak256("eth_defi.gmx.v1"))

    // ----- Protocol: CCTP V2 -----

    // Allowed CCTP TokenMessengerV2 instances.
    //
    // TokenMessengerV2 is the entry point for cross-chain USDC transfers.
    // USDC must be approved to TokenMessengerV2 before calling depositForBurn().
    //
    mapping(address messenger => bool allowed) public allowedCCTPMessengers;

    // Allowed CCTP destination domains.
    //
    // CCTP uses its own domain IDs (not EVM chain IDs).
    // E.g. Ethereum=0, Arbitrum=3, Base=6, Polygon=7.
    //
    mapping(uint32 domain => bool allowed) public allowedCCTPDestinations;

    // ----- Protocol: Hypercore -----
    // State is managed by HypercoreVaultLib via diamond storage.
    // No storage variables needed here â€” the library uses a deterministic
    // keccak slot to avoid collisions with this contract's layout.

    // ----- Dangerous flags -----

    // Allow trading any token
    //
    // Dangerous, as malicious/compromised trade-executor can drain all assets through creating fake tokens
    //
    bool public anyAsset;

    // ========================================================================
    //                                 EVENTS
    // ========================================================================

    event CallSiteApproved(address target, bytes4 selector, string notes);
    event CallSiteRemoved(address target, bytes4 selector, string notes);

    event SenderApproved(address sender, string notes);
    event SenderRemoved(address sender, string notes);

    event ReceiverApproved(address receiver, string notes);
    event ReceiverRemoved(address receiver, string notes);

    event WithdrawDestinationApproved(address destination, string notes);
    event WithdrawDestinationRemoved(address destination, string notes);

    event ApprovalDestinationApproved(address destination, string notes);
    event ApprovalDestinationRemoved(address destination, string notes);

    event DelegationApprovalDestinationApproved(
        address destination,
        string notes
    );
    event DelegationApprovalDestinationRemoved(
        address destination,
        string notes
    );

    event AssetApproved(address asset, string notes);
    event AssetRemoved(address asset, string notes);

    event AnyAssetSet(bool value, string notes);
    event AnyVaultSet(bool value, string notes);

    event LagoonVaultApproved(address vault, string notes);

    event VeloraSwapperApproved(address augustusSwapper, string notes);
    event ERC4626Approved(address vault, string notes);
    event CCTPMessengerApproved(address tokenMessenger, string notes);
    event CCTPDestinationApproved(uint32 domain, string notes);
    event CCTPDestinationRemoved(uint32 domain, string notes);

    // Velora swap execution event - emitted after successful atomic swap
    event VeloraSwapExecuted(
        uint256 indexed timestamp,
        address indexed augustusSwapper,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 minAmountOut
    );

    // Implementation needs to provide its own ownership policy hooks
    modifier onlyGuardOwner() virtual;

    // Implementation needs to provide its own ownership policy hooks
    function getGovernanceAddress() public view virtual returns (address);

    /**
     * Calculate Solidity 4-byte function selector from a string.
     */
    function getSelector(string memory _func) internal pure returns (bytes4) {
        // https://solidity-by-example.org/function-selector/
        return bytes4(keccak256(bytes(_func)));
    }

    /**
     * Track version during internal development.
     *
     * We bump up when new whitelistings added.
     */
    function getInternalVersion() public pure returns (uint8) {
        return 1;
    }

    function allowCallSite(
        address target,
        bytes4 selector,
        string calldata notes
    ) public onlyGuardOwner {
        allowedCallSites[target][selector] = true;
        allowedTargets[target] = true;
        callSiteCount++;
        emit CallSiteApproved(target, selector, notes);
    }

    function removeCallSite(
        address target,
        bytes4 selector,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedCallSites[target][selector];
        emit CallSiteRemoved(target, selector, notes);
    }

    function allowSender(
        address sender,
        string calldata notes
    ) public onlyGuardOwner {
        allowedSenders[sender] = true;
        emit SenderApproved(sender, notes);
    }

    function removeSender(
        address sender,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedSenders[sender];
        emit SenderRemoved(sender, notes);
    }

    // Whitelist an address as a valid receiver for trading operations.
    //
    // IMPORTANT: The Safe/vault address must be whitelisted here for GMX, Aave, Uniswap,
    // ERC-4626, and other protocols that send funds to a recipient address.
    // Without this, trading operations will fail validation.
    //
    // Example: guard.allowReceiver(safeAddress, "Safe vault address");
    //
    function allowReceiver(
        address receiver,
        string calldata notes
    ) public onlyGuardOwner {
        allowedReceivers[receiver] = true;
        emit ReceiverApproved(receiver, notes);
    }

    function removeReceiver(
        address receiver,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedReceivers[receiver];
        emit ReceiverRemoved(receiver, notes);
    }

    function allowWithdrawDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        allowedWithdrawDestinations[destination] = true;
        emit WithdrawDestinationApproved(destination, notes);
    }

    function removeWithdrawDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedWithdrawDestinations[destination];
        emit WithdrawDestinationRemoved(destination, notes);
    }

    function allowApprovalDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        allowedApprovalDestinations[destination] = true;
        emit ApprovalDestinationApproved(destination, notes);
    }

    function removeApprovalDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedApprovalDestinations[destination];
        emit ApprovalDestinationRemoved(destination, notes);
    }

    function allowDelegationApprovalDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        allowedDelegationApprovalDestinations[destination] = true;
        emit ApprovalDestinationApproved(destination, notes);
    }

    function removeDelegationApprovalDestination(
        address destination,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedDelegationApprovalDestinations[destination];
        emit DelegationApprovalDestinationRemoved(destination, notes);
    }

    function allowAsset(
        address asset,
        string calldata notes
    ) public onlyGuardOwner {
        allowedAssets[asset] = true;
        emit AssetApproved(asset, notes);
    }

    function removeAsset(
        address asset,
        string calldata notes
    ) public onlyGuardOwner {
        delete allowedAssets[asset];
        emit AssetRemoved(asset, notes);
    }

    function whitelistLagoon(
        address vault,
        string calldata notes
    ) public onlyGuardOwner {
        allowedLagoonVaults[vault] = true;
        allowCallSite(vault, SEL_SETTLE_DEPOSIT, notes);
        allowCallSite(vault, SEL_SETTLE_REDEEM, notes);
        // Lagoon v0.5.0+
        allowCallSite(vault, SEL_SETTLE_DEPOSIT_UINT, notes);
        allowCallSite(vault, SEL_SETTLE_REDEEM_UINT, notes);
        emit LagoonVaultApproved(vault, notes);
    }

    function isAnyTokenApproveSelector(
        bytes4 selector
    ) internal pure returns (bool) {
        return selector == SEL_APPROVE;
    }

    // Basic check if any target contract is whitelisted
    function isAllowedCallSite(
        address target,
        bytes4 selector
    ) public view returns (bool) {
        return allowedCallSites[target][selector];
    }

    function isAllowedTarget(address target) public view returns (bool) {
        return allowedTargets[target];
    }

    function isAllowedSender(address sender) public view returns (bool) {
        return allowedSenders[sender];
    }

    // Check if an address is whitelisted to receive funds from trading operations.
    //
    // Returns true if the address was previously whitelisted via allowReceiver().
    // This is the primary mechanism for ensuring funds flow to authorised destinations.
    //
    function isAllowedReceiver(address receiver) public view returns (bool) {
        return allowedReceivers[receiver];
    }

    function isAllowedWithdrawDestination(
        address receiver
    ) public view returns (bool) {
        return allowedWithdrawDestinations[receiver];
    }

    function isAllowedApprovalDestination(
        address receiver
    ) public view returns (bool) {
        return allowedApprovalDestinations[receiver];
    }

    function isAllowedDelegationApprovalDestination(
        address receiver
    ) public view returns (bool) {
        return allowedDelegationApprovalDestinations[receiver];
    }

    /**
     * Are we allowed to trade/own an ERC-20.
     */
    function isAllowedAsset(address token) public view returns (bool) {
        return anyAsset || allowedAssets[token];
    }

    function isAllowedLagoonVault(address vault) public view returns (bool) {
        return allowedLagoonVaults[vault];
    }

    function isAllowedCowSwap(address settlement) public view returns (bool) {
        return CowSwapLib.isAllowedCowSwap(settlement);
    }

    function isAllowedVeloraSwapper(
        address swapper
    ) public view returns (bool) {
        return allowedVeloraSwappers[swapper];
    }

    function validate_transfer(bytes memory callData) internal view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(isAllowedWithdrawDestination(to), "Receiver not whitelisted");
    }

    function validate_approve(bytes memory callData) internal view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(
            isAllowedApprovalDestination(to),
            "Approve address not allowed"
        );
    }

    function validate_approveDelegation(bytes memory callData) internal view {
        (address to, ) = abi.decode(callData, (address, uint));
        require(
            isAllowedDelegationApprovalDestination(to),
            "Delegation address not allowed"
        );
    }

    // Make this callable both internally and externally
    function _whitelistToken(address token, string calldata notes) internal {
        allowCallSite(token, SEL_TRANSFER, notes);
        allowCallSite(token, SEL_APPROVE, notes);
        allowAsset(token, notes);
    }

    // Allow ERC-20.approve() to a specific asset and this asset used as the part of path of swaps
    function whitelistToken(address token, string calldata notes) external {
        _whitelistToken(token, notes);
    }

    function whitelistTokenForDelegation(
        address token,
        string calldata notes
    ) external {
        allowCallSite(token, SEL_APPROVE_DELEGATION, notes);
        allowAsset(token, notes);
    }

    // Whitelist SwapRouter or SwapRouter02
    function whitelistUniswapV3Router(
        address router,
        string calldata notes
    ) external {
        allowCallSite(router, SEL_EXACT_INPUT, notes);
        allowCallSite(router, SEL_EXACT_OUTPUT, notes);
        allowCallSite(router, SEL_EXACT_INPUT_ROUTER02, notes);
        allowApprovalDestination(router, notes);
    }

    function whitelistUniswapV2Router(
        address router,
        string calldata notes
    ) external {
        allowCallSite(router, SEL_SWAP_EXACT_TOKENS, notes);
        allowCallSite(router, SEL_SWAP_EXACT_TOKENS_FEE, notes);
        allowApprovalDestination(router, notes);
    }

    // Enable unlimited trading space
    function setAnyAssetAllowed(
        bool value,
        string calldata notes
    ) external onlyGuardOwner {
        anyAsset = value;
        emit AnyAssetSet(value, notes);
    }

    // Satisfy IGuard
    function validateCall(
        address sender,
        address target,
        bytes calldata callDataWithSelector
    ) external view {
        _validateCallInternal(sender, target, callDataWithSelector);
    }

    function _validateCallInternal(
        address sender,
        address target,
        bytes calldata callDataWithSelector
    ) internal view {
        // Governance can always perform any action through guard.
        // We enable this so that direct governance voted actions can fix mess
        // caused by hung contracts, etc.
        if (sender == getGovernanceAddress()) {
            return;
        }

        // Assume sender is trade-executor hot wallet
        require(isAllowedSender(sender), "Sender not allowed");

        bytes4 selector = bytes4(callDataWithSelector[:4]);
        bytes calldata callData = callDataWithSelector[4:];

        // If we have dynamic whitelist/any token, we cannot check approve() call sites of
        // individual tokens
        bool anyTokenCheck = anyAsset && isAnyTokenApproveSelector(selector);

        // Hypercore selectors are validated by dedicated branches below and bypass
        // the general allowCallSite registry (saves bytecode by avoiding extra call site
        // registrations in whitelistCoreWriter).
        bool hypercoreCheck = (selector == SEL_SEND_RAW_ACTION ||
            selector == SEL_CORE_DEPOSIT);

        // With anyToken, we cannot check approve() call site because we do not whitelist
        // individual token addresses
        if (!anyTokenCheck && !hypercoreCheck) {
            if (!isAllowedCallSite(target, selector)) {
                require(isAllowedTarget(target), "Target not allowed");
                require(
                    isAllowedCallSite(target, selector),
                    "Selector not allowed"
                );
            }
        }

        // Validate the function payload.
        // Depends on the called protocol.

        // --- DEX swaps (Uniswap V2/V3) ---
        if (selector == SEL_SWAP_EXACT_TOKENS) {
            validate_swapExactTokensForTokens(callData);
        } else if (selector == SEL_SWAP_EXACT_TOKENS_FEE) {
            validate_swapExactTokensForTokens(callData);
        } else if (selector == SEL_EXACT_INPUT) {
            validate_exactInput(callData);
        } else if (selector == SEL_EXACT_INPUT_ROUTER02) {
            // See whitelistUniswapV3Router
            require(anyAsset, "SwapRouter02 requires anyAsset");

            // --- ERC-20 token operations ---
        } else if (selector == SEL_TRANSFER) {
            validate_transfer(callData);
        } else if (selector == SEL_APPROVE) {
            validate_approve(callData);
        } else if (selector == SEL_APPROVE_DELEGATION) {
            validate_approveDelegation(callData);

            // --- Aave V3 lending ---
        } else if (selector == SEL_AAVE_SUPPLY) {
            validate_aaveSupply(callData);
        } else if (selector == SEL_AAVE_WITHDRAW) {
            validate_aaveWithdraw(callData);

            // --- Lagoon vault settlement ---
        } else if (
            selector == SEL_SETTLE_DEPOSIT ||
            selector == SEL_SETTLE_REDEEM ||
            selector == SEL_SETTLE_DEPOSIT_UINT ||
            selector == SEL_SETTLE_REDEEM_UINT
        ) {
            validate_lagoonSettle(target);

            // --- ERC-4626 / ERC-7540 vaults ---
        } else if (selector == SEL_DEPOSIT || selector == SEL_DEPOSIT_7540) {
            // Guard logic in approve() whitelist - no further checks here needed
        } else if (selector == SEL_DEPOSIT_UMAMI) {
            // Umami non-standard ERC-4626 deposit with minShares slippage parameter
            validate_UmamiDeposit(callData);
        } else if (selector == SEL_REDEEM_UMAMI) {
            // Umami non-standard ERC-4626 redeem with minShares slippage parameter
            validate_UmamiRedeem(callData);
        } else if (selector == SEL_WITHDRAW) {
            _validate_ERC4626WithdrawOrRedeem(callData);
        } else if (selector == SEL_REDEEM) {
            _validate_ERC4626WithdrawOrRedeem(callData);
        } else if (selector == SEL_REQUEST_REDEEM) {
            // ERC-7540: same parameters as ERC-4626
            _validate_ERC4626WithdrawOrRedeem(callData);
        } else if (selector == SEL_REQUEST_WITHDRAW) {
            // ERC-7540: same parameters as ERC-4626
            _validate_ERC4626WithdrawOrRedeem(callData);
        } else if (selector == SEL_REQUEST_DEPOSIT) {
            // Guard logic in approve() whitelist - no further checks here needed
        } else if (selector == SEL_MAKE_WITHDRAW_REQUEST) {
            // Gains/Ostium modified ERC-4626: makeWithdrawRequest(uint256,address)
            validate_makeWithdrawRequest(callData);

            // --- Orderly perpetuals ---
        } else if (selector == SEL_DELEGATE_SIGNER) {
            // TODO: Implement Orderly validation
        } else if (selector == SEL_ORDERLY_DEPOSIT) {
            // TODO: Implement Orderly validation
        } else if (selector == SEL_ORDERLY_WITHDRAW) {
            // TODO: Implement Orderly validation
            // --- GMX perpetuals ---
        } else if (selector == SEL_GMX_MULTICALL) {
            _validate_gmxMulticall(target, callData);

            // --- CCTP cross-chain transfers ---
        } else if (selector == SEL_CCTP_DEPOSIT_FOR_BURN) {
            validate_cctpDepositForBurn(target, callData);

            // --- Hypercore CoreWriter ---
        } else if (selector == SEL_SEND_RAW_ACTION) {
            (uint24 actionId, address dest) = HypercoreVaultLib.validateAction(
                target,
                callData
            );
            if (actionId == 6) {
                // SPOT_SEND_ACTION
                require(isAllowedReceiver(dest), "CoreWriter spotSend receiver not allowed");
            }

            // --- Hypercore CoreDepositWallet ---
        } else if (selector == SEL_CORE_DEPOSIT) {
            HypercoreVaultLib.validateDeposit(target);
        } else {
            revert("Unknown function selector");
        }
    }

    // Validate Uniswap v2 trade
    function validate_swapExactTokensForTokens(
        bytes memory callData
    ) internal view {
        (, , address[] memory path, address to, ) = abi.decode(
            callData,
            (uint, uint, address[], address, uint)
        );
        require(isAllowedReceiver(to), "Receiver not whitelisted");
        address token;
        for (uint256 i = 0; i < path.length; i++) {
            token = path[i];
            require(isAllowedAsset(token), "Token not allowed");
        }
    }

    // Validate Uniswap v3 trade
    function validate_exactInput(bytes memory callData) internal view {
        (ExactInputParams memory params) = abi.decode(
            callData,
            (ExactInputParams)
        );
        require(
            isAllowedReceiver(params.recipient),
            "Receiver not whitelisted"
        );
        validateUniswapV3Path(params.path);
    }

    function validate_exactOutput(bytes memory callData) internal view {
        (ExactOutputParams memory params) = abi.decode(
            callData,
            (ExactOutputParams)
        );
        require(
            isAllowedReceiver(params.recipient),
            "Receiver not whitelisted"
        );
        validateUniswapV3Path(params.path);
    }

    function validateUniswapV3Path(bytes memory path) internal view {
        address tokenIn;
        address tokenOut;
        while (true) {
            (tokenOut, tokenIn, ) = path.decodeFirstPool();
            require(isAllowedAsset(tokenIn), "Token not allowed");
            require(isAllowedAsset(tokenOut), "Token not allowed");
            if (path.hasMultiplePools()) {
                path = path.skipToken();
            } else {
                break;
            }
        }
    }

    // Gains/Ostium: validate makeWithdrawRequest(uint256,address) receiver
    function validate_makeWithdrawRequest(bytes memory callData) internal view {
        (, address receiver) = abi.decode(callData, (uint256, address));
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // ERC-4626/ERC-7540: validate withdraw or redeem receiver
    function _validate_ERC4626WithdrawOrRedeem(
        bytes memory callData
    ) internal view {
        (, address receiver, ) = abi.decode(
            callData,
            (uint256, address, address)
        );
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // Umami non-standard ERC-4626 deposit
    function validate_UmamiDeposit(bytes memory callData) internal view {
        (, , address receiver) = abi.decode(
            callData,
            (uint256, uint256, address)
        );
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    // Umami non-standard ERC-4626 redeem
    function validate_UmamiRedeem(bytes memory callData) internal view {
        (, , address receiver, ) = abi.decode(
            callData,
            (uint256, uint256, address, address)
        );
        require(isAllowedReceiver(receiver), "Receiver not whitelisted");
    }

    /**
     * Whitelist an ERC-4626/ERC-7540 vault.
     *
     * - Callsites for deposits and redemptions
     * - Vault share and denomination tokens
     * - Any ERC-4626 extensions are not supported by this function, like special share tokens
     * - ERC-4626 withdrawal address must be always the Safe
     * - Because of non-standardisation the whitelisted function list is long
     */
    function whitelistERC4626(address vault, string calldata notes) external {
        IERC4626 vault_ = IERC4626(vault);
        address denominationToken = vault_.asset();
        address shareToken = vault;

        // ERC-4626
        allowCallSite(vault, SEL_DEPOSIT, notes);
        allowCallSite(vault, SEL_WITHDRAW, notes);
        allowCallSite(vault, SEL_REDEEM, notes);

        // Umami non-standard ERC-4626
        allowCallSite(vault, SEL_DEPOSIT_UMAMI, notes);
        allowCallSite(vault, SEL_REDEEM_UMAMI, notes);

        // ERC-7540
        allowCallSite(vault, SEL_DEPOSIT_7540, notes);
        allowCallSite(vault, SEL_REQUEST_REDEEM, notes);
        allowCallSite(vault, SEL_REQUEST_WITHDRAW, notes);
        allowCallSite(vault, SEL_REQUEST_DEPOSIT, notes);

        // Ostium/Gains
        allowCallSite(vault, SEL_MAKE_WITHDRAW_REQUEST, notes);

        allowApprovalDestination(vault, notes);
        _whitelistToken(shareToken, notes);
        _whitelistToken(denominationToken, notes);

        emit ERC4626Approved(vault, notes);
    }

    // Aave V3 implementation
    function validate_aaveSupply(bytes memory callData) internal view {
        (address token, , , ) = abi.decode(
            callData,
            (address, uint, address, uint)
        );
        require(isAllowedAsset(token), "Token not allowed");
    }

    function validate_aaveWithdraw(bytes memory callData) internal view {
        (address token, , address to) = abi.decode(
            callData,
            (address, uint, address)
        );
        require(isAllowedAsset(token), "Token not allowed");
        require(isAllowedReceiver(to), "Receiver not whitelisted");
    }

    function whitelistAaveV3(
        address lendingPool,
        string calldata notes
    ) external {
        allowCallSite(lendingPool, SEL_AAVE_SUPPLY, notes);
        allowCallSite(lendingPool, SEL_AAVE_WITHDRAW, notes);
        allowApprovalDestination(lendingPool, notes);
    }

    function validate_lagoonSettle(address vault) internal view {
        require(isAllowedLagoonVault(vault), "Vault not allowed");
    }

    function whitelistOrderly(
        address orderlyVault,
        string calldata notes
    ) external {
        allowCallSite(orderlyVault, SEL_DELEGATE_SIGNER, notes);
        allowCallSite(orderlyVault, SEL_ORDERLY_DEPOSIT, notes);
        allowCallSite(orderlyVault, SEL_ORDERLY_WITHDRAW, notes);
        allowApprovalDestination(orderlyVault, notes);
    }

    // https://github.com/cowprotocol/contracts/tree/main/deployments
    function whitelistCowSwap(
        address settlementContract,
        address relayerContract,
        string calldata notes
    ) external {
        // Interaction by special _swapAndValidateCowSwap() internal function
        allowApprovalDestination(settlementContract, notes);
        allowApprovalDestination(relayerContract, notes);
        CowSwapLib.whitelistCowSwap(settlementContract, notes);
    }

    // Whitelist Velora (ParaSwap) Augustus Swapper for atomic swaps.
    //
    // TokenTransferProxy must be approved for token spending (not Augustus).
    // See: https://developers.velora.xyz
    //
    function whitelistVelora(
        address augustusSwapper,
        address tokenTransferProxy,
        string calldata notes
    ) external onlyGuardOwner {
        allowApprovalDestination(tokenTransferProxy, notes);
        allowedVeloraSwappers[augustusSwapper] = true;
        emit VeloraSwapperApproved(augustusSwapper, notes);
    }

    // Whitelist GMX Exchange Router for perpetuals trading.
    //
    // GMX uses multicall() on ExchangeRouter to batch: sendWnt, sendTokens, createOrder.
    // SyntheticsRouter must be approved for collateral token spending.
    // OrderVault is where tokens are sent before order execution.
    //
    // IMPORTANT: After calling this function, you must also:
    // 1. Call allowReceiver(safeAddress, "notes") to whitelist the Safe as order receiver
    // 2. Call whitelistGMXMarket(market, "notes") for each allowed market (or setAnyAssetAllowed)
    // 3. Call whitelistToken(collateralToken, "notes") for each collateral token (or setAnyAssetAllowed)
    //
    // See: https://docs.gmx.io
    //
    function whitelistGMX(
        address exchangeRouter,
        address syntheticsRouter,
        address orderVault,
        string calldata notes
    ) external onlyGuardOwner {
        allowCallSite(exchangeRouter, SEL_GMX_MULTICALL, notes);
        allowApprovalDestination(syntheticsRouter, notes);
        GmxLib.whitelistRouter(
            exchangeRouter,
            syntheticsRouter,
            orderVault,
            notes
        );
    }

    function isAllowedGMXRouter(address router) public view returns (bool) {
        return GmxLib.isAllowedRouter(router);
    }

    function whitelistGMXMarket(
        address market,
        string calldata notes
    ) external onlyGuardOwner {
        GmxLib.whitelistMarket(market, notes);
    }

    function removeGMXMarket(
        address market,
        string calldata notes
    ) external onlyGuardOwner {
        GmxLib.removeMarket(market, notes);
    }

    function isAllowedGMXMarket(address market) public view returns (bool) {
        return GmxLib.isAllowedMarket(market, anyAsset);
    }

    function gmxOrderVaults(
        address exchangeRouter
    ) public view returns (address) {
        return GmxLib.getOrderVault(exchangeRouter);
    }

    // Whitelist CCTP TokenMessengerV2 for cross-chain USDC transfers.
    //
    // TokenMessengerV2.depositForBurn() is the main call that burns USDC on source chain.
    // USDC must be approved to TokenMessengerV2 for spending.
    //
    // IMPORTANT: After calling this function, you must also:
    // 1. Call whitelistCCTPDestination(domain, "notes") for each allowed destination chain
    // 2. Call whitelistToken(usdcAddress, "notes") for the USDC token on this chain
    // 3. Call allowReceiver(recipientAddress, "notes") for allowed mint recipients
    //
    // See: https://developers.circle.com/cctp
    //
    function whitelistCCTP(
        address tokenMessenger,
        string calldata notes
    ) external onlyGuardOwner {
        allowCallSite(tokenMessenger, SEL_CCTP_DEPOSIT_FOR_BURN, notes);
        allowApprovalDestination(tokenMessenger, notes);
        allowedCCTPMessengers[tokenMessenger] = true;
        emit CCTPMessengerApproved(tokenMessenger, notes);
    }

    // Whitelist a CCTP destination domain for cross-chain transfers.
    //
    // CCTP uses its own domain IDs (not EVM chain IDs):
    // Ethereum=0, Arbitrum=3, Base=6, Polygon=7
    //
    function whitelistCCTPDestination(
        uint32 domain,
        string calldata notes
    ) external onlyGuardOwner {
        allowedCCTPDestinations[domain] = true;
        emit CCTPDestinationApproved(domain, notes);
    }

    function removeCCTPDestination(
        uint32 domain,
        string calldata notes
    ) external onlyGuardOwner {
        allowedCCTPDestinations[domain] = false;
        emit CCTPDestinationRemoved(domain, notes);
    }

    function isAllowedCCTPMessenger(
        address messenger
    ) public view returns (bool) {
        return allowedCCTPMessengers[messenger];
    }

    function isAllowedCCTPDestination(
        uint32 domain
    ) public view returns (bool) {
        return allowedCCTPDestinations[domain];
    }

    // Whitelist Hypercore CoreWriter and CoreDepositWallet.
    // Enables action IDs 2 (vaultTransfer), 6 (spotSend), 7 (transferUsdClass).
    // CoreWriter/CoreDepositWallet call sites are handled by dedicated validation
    // branches (bypassing the general allowCallSite check) to save bytecode.
    // See README-Hypercore-guard.md for full documentation.
    function whitelistCoreWriter(
        address coreWriter,
        address coreDepositWallet,
        string calldata notes
    ) external onlyGuardOwner {
        HypercoreVaultLib.whitelistCoreWriter(
            coreWriter,
            coreDepositWallet,
            notes
        );
        // Allow USDC approve to CoreDepositWallet for bridging
        allowApprovalDestination(coreDepositWallet, notes);
    }

    // Whitelist a Hypercore native vault address for deposits/withdrawals.
    function whitelistHypercoreVault(
        address vault,
        string calldata notes
    ) external onlyGuardOwner {
        HypercoreVaultLib.whitelistHypercoreVault(vault, notes);
    }

    // Remove a previously whitelisted Hypercore vault.
    function removeHypercoreVault(
        address vault,
        string calldata notes
    ) external onlyGuardOwner {
        HypercoreVaultLib.removeHypercoreVault(vault, notes);
    }

    // Validate a GMX multicall payload.
    //
    // Delegates parsing, decoding, and GMX-internal checks (router, orderVault,
    // markets) to GmxLib. The library returns arrays of addresses that need
    // cross-cutting checks (isAllowedAsset, isAllowedReceiver) which only the
    // main contract can perform (since it owns the asset/receiver storage).
    //
    function _validate_gmxMulticall(
        address exchangeRouter,
        bytes calldata callData
    ) internal view {
        (
            address[] memory assets,
            address[] memory receivers,
            address[] memory markets
        ) = GmxLib.validateMulticall(exchangeRouter, callData, anyAsset);

        for (uint256 i = 0; i < assets.length; i++) {
            require(isAllowedAsset(assets[i]), "GMX: asset not allowed");
        }
        for (uint256 i = 0; i < receivers.length; i++) {
            require(
                isAllowedReceiver(receivers[i]),
                "GMX: receiver not allowed"
            );
        }
        for (uint256 i = 0; i < markets.length; i++) {
            require(
                GmxLib.isAllowedMarket(markets[i], anyAsset),
                "GMX: market not allowed"
            );
        }
    }

    // Validate CCTP depositForBurn call parameters.
    //
    // Checks:
    // - TokenMessenger is whitelisted
    // - Destination domain is whitelisted
    // - Burn token (USDC) is an allowed asset
    // - Mint recipient (converted from bytes32 to address) is an allowed receiver
    //
    function validate_cctpDepositForBurn(
        address target,
        bytes calldata callData
    ) internal view {
        require(isAllowedCCTPMessenger(target), "CCTP messenger not allowed");

        (
            , // uint256 amount
            uint32 destinationDomain,
            bytes32 mintRecipient,
            address burnToken,
            , // bytes32 destinationCaller
            , // uint256 maxFee

        ) = abi.decode( // uint32 minFinalityThreshold
                callData,
                (uint256, uint32, bytes32, address, bytes32, uint256, uint32)
            );

        require(
            isAllowedCCTPDestination(destinationDomain),
            "CCTP destination not allowed"
        );
        require(isAllowedAsset(burnToken), "CCTP burn token not allowed");

        // Convert bytes32 mintRecipient to address (last 20 bytes)
        address recipient = address(uint160(uint256(mintRecipient)));
        require(
            isAllowedReceiver(recipient),
            "CCTP mint recipient not allowed"
        );
    }

    // Validate Velora swap and compute pre-swap balance
    //
    // Returns the pre-swap balance of tokenOut for slippage verification
    //
    function _validateVeloraSwapAndGetPreBalance(
        address safeAddress,
        address augustusSwapper,
        address tokenIn,
        address tokenOut
    ) internal view returns (uint256) {
        require(
            isAllowedVeloraSwapper(augustusSwapper),
            "Velora swapper not enabled"
        );
        require(isAllowedSender(msg.sender), "Sender not allowed");
        require(isAllowedAsset(tokenIn), "tokenIn not allowed");
        require(isAllowedAsset(tokenOut), "tokenOut not allowed");
        return IERC20(tokenOut).balanceOf(safeAddress);
    }

    // Verify slippage after Velora swap execution and emit event
    //
    // Call this after executing the swap calldata on the Safe
    //
    function _verifyVeloraSwapAndEmit(
        address safeAddress,
        address augustusSwapper,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 preBalance
    ) internal {
        uint256 postBalance = IERC20(tokenOut).balanceOf(safeAddress);
        require(
            postBalance >= preBalance + minAmountOut,
            "Insufficient output amount"
        );

        emit VeloraSwapExecuted(
            block.timestamp,
            augustusSwapper,
            tokenIn,
            tokenOut,
            amountIn,
            postBalance - preBalance,
            minAmountOut
        );
    }

    /**
     * Swap and validate a CowSwap order.
     *
     * Checks that an asset manager tries to perform a legit CowSwap swap.
     *
     * 1. Validate the swap is within our allowed whitelists
     * 2. Create a Order structure
     * 3. Calculate order data hash and prefix with additional information to create order UID
     * 4. Set up data needed to call ICowSettlement.setPreSignature(orderUid, True) from Gnosis Safe as a
     * 5. Return data to call setPreSignature(orderUid, True) on CowSwap by Safe
     * 6. Offchain logic can now take over to fill the order
     *     6.a) Read the emitted order data from OrderSigned event
     *     6.b) Submit to CowSwap offchain settlement system
     *     6.c) Wait for order to be filled
     *
     * Assume receiver is the same as owner that is the same as the Gnosis Safe address.
     */
    function _swapAndValidateCowSwap(
        address settlementContract,
        address receiver,
        bytes32 appData,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) internal returns (PresignCallData memory) {
        require(
            CowSwapLib.isAllowedCowSwap(settlementContract),
            "CowSwap not enabled"
        );
        require(isAllowedSender(msg.sender), "Sender not allowed");
        require(isAllowedAsset(tokenIn), "tokenIn not allowed");
        require(isAllowedAsset(tokenOut), "tokenOut not allowed");
        require(isAllowedReceiver(receiver), "Receiver not allowed");
        return
            CowSwapLib.createAndSignOrder(
                settlementContract,
                receiver,
                appData,
                tokenIn,
                tokenOut,
                amountIn,
                minAmountOut
            );
    }
}
