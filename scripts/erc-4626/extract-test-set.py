"""Extract a test set for a single vault.

- Reads the local vault metadata database and uncleaned (raw) price Parquet
- Filters to a single vault by chain_id + address
- Outputs a pytest test module and companion Parquet file into tests/research/

Usage:

    poetry run python scripts/erc-4626/extract-test-set.py

Configure with environment variables:
    CHAIN_ID - chain id (default: 8453)
    VAULT_ADDRESS - vault address (default: 0x67b93f6676bd1911c5fae7ffa90fff5f35e14dcd)
    TEST_NAME - slug for output filenames (default: base_usdc_yield_dynavault_v3)
"""

import os
import textwrap
from pathlib import Path

import pandas as pd

from eth_defi.vault.base import VaultSpec
from eth_defi.vault.vaultdb import DEFAULT_UNCLEANED_PRICE_DATABASE, DEFAULT_VAULT_DATABASE, VaultDatabase


def main():
    chain_id = int(os.environ.get("CHAIN_ID", "8453"))
    vault_address = os.environ.get("VAULT_ADDRESS", "0x67b93f6676bd1911c5fae7ffa90fff5f35e14dcd").lower()
    test_name = os.environ.get("TEST_NAME", "base_usdc_yield_dynavault_v3")

    vault_spec = VaultSpec(chain_id=chain_id, vault_address=vault_address)
    vault_id = vault_spec.as_string_id()

    # Output directory
    output_dir = Path(__file__).resolve().parent.parent.parent / "tests" / "research"
    assert output_dir.exists(), f"Output directory does not exist: {output_dir}"

    # --- Load vault metadata ---
    vault_db = VaultDatabase.read(DEFAULT_VAULT_DATABASE)
    vault_row = vault_db.rows.get(vault_spec)
    assert vault_row is not None, f"Vault {vault_id} not found in vault database at {DEFAULT_VAULT_DATABASE}"

    # Extract key metadata fields
    name = vault_row.get("Name", "Unknown")
    symbol = vault_row.get("Symbol", "Unknown")
    denomination = vault_row.get("Denomination", "Unknown")
    protocol = vault_row.get("Protocol", "Unknown")
    link = vault_row.get("Link")
    mgmt_fee = vault_row.get("Mgmt fee")
    perf_fee = vault_row.get("Perf fee")
    deposit_fee = vault_row.get("Deposit fee", 0)
    withdraw_fee = vault_row.get("Withdrawal fee", 0)

    print(f"Vault: {name} ({symbol})")
    print(f"Protocol: {protocol}")
    print(f"Denomination: {denomination}")
    print(f"Fees: mgmt={mgmt_fee}, perf={perf_fee}, deposit={deposit_fee}, withdraw={withdraw_fee}")

    # --- Load and filter uncleaned (raw) price data ---
    price_df = pd.read_parquet(DEFAULT_UNCLEANED_PRICE_DATABASE, filters=[("chain", "==", chain_id)])
    vault_prices = price_df[price_df["address"] == vault_address]

    assert len(vault_prices) > 0, f"No price data found for vault {vault_id} in {DEFAULT_UNCLEANED_PRICE_DATABASE}"

    print(f"Price data: {vault_prices.index.min()} to {vault_prices.index.max()}, {len(vault_prices)} rows")

    # --- Write companion Parquet ---
    parquet_filename = f"vault-{test_name.replace('_', '-')}-prices-1h.parquet"
    parquet_path = output_dir / parquet_filename
    vault_prices.to_parquet(parquet_path)
    print(f"Wrote {parquet_path} ({parquet_path.stat().st_size / 1024:.1f} KB)")

    # --- Compute sample values for assertions ---
    share_prices = vault_prices["share_price"].dropna()
    first_share_price = share_prices.iloc[0]
    last_share_price = share_prices.iloc[-1]
    total_assets = vault_prices["total_assets"].dropna()
    last_total_assets = total_assets.iloc[-1]
    row_count = len(vault_prices)

    # --- Generate pytest module ---
    test_filename = f"test_vault_{test_name}.py"
    test_path = output_dir / test_filename

    test_content = textwrap.dedent(f'''\
        """Test data integrity for {name} vault on chain {chain_id}.

        Vault: {name} ({symbol})
        Chain: {chain_id} (Base)
        Address: {vault_address}
        Protocol: {protocol}
        Denomination: {denomination}
        Link: {link}

        Fees:
            Management: {mgmt_fee}
            Performance: {perf_fee}
            Deposit: {deposit_fee}
            Withdrawal: {withdraw_fee}

        Generated by scripts/erc-4626/extract-test-set.py
        """

        import os.path
        from pathlib import Path

        import pandas as pd
        import pytest

        from eth_defi.research.wrangle_vault_prices import remove_inactive_lead_time


        CHAIN_ID = {chain_id}
        VAULT_ADDRESS = "{vault_address}"


        @pytest.fixture(scope="module")
        def price_df() -> pd.DataFrame:
            """Load extracted raw price data for this vault."""
            path = Path(os.path.dirname(__file__)) / "{parquet_filename}"
            return pd.read_parquet(path)


        def test_price_data_not_empty(price_df: pd.DataFrame):
            """Verify we have price data rows."""
            assert len(price_df) > 0
            assert len(price_df) == {row_count}


        def test_correct_vault_address(price_df: pd.DataFrame):
            """Verify all rows belong to the expected vault."""
            addresses = price_df["address"].unique()
            assert len(addresses) == 1
            assert addresses[0] == VAULT_ADDRESS


        def test_share_price_exists(price_df: pd.DataFrame):
            """Verify share_price column has data."""
            share_prices = price_df["share_price"].dropna()
            assert len(share_prices) > 0
            assert share_prices.iloc[0] == pytest.approx({first_share_price}, rel=1e-4)
            assert share_prices.iloc[-1] == pytest.approx({last_share_price}, rel=1e-4)


        def test_total_assets_exists(price_df: pd.DataFrame):
            """Verify total_assets column has data."""
            total_assets = price_df["total_assets"].dropna()
            assert len(total_assets) > 0
            assert total_assets.iloc[-1] == pytest.approx({last_total_assets}, rel=0.01)


        def test_required_columns(price_df: pd.DataFrame):
            """Verify all expected raw price columns are present."""
            required = ["chain", "address", "block_number", "share_price", "total_assets",
                        "total_supply", "performance_fee", "management_fee"]
            for col in required:
                assert col in price_df.columns, f"Missing column: {{col}}"


        def test_chain_id_correct(price_df: pd.DataFrame):
            """Verify the chain ID in the data matches."""
            chains = price_df["chain"].unique()
            assert len(chains) == 1
            assert int(chains[0]) == CHAIN_ID


        def test_remove_inactive_lead_time(price_df: pd.DataFrame):
            """Check eliminating the empty lead period of data.

            - Verify that remove_inactive_lead_time() correctly strips the initial
              period where total_supply is constant (no deposits/redemptions yet)
            - Raw data needs 'id' column and timestamp index for remove_inactive_lead_time()
            """
            df = price_df.copy()
            df["id"] = df["chain"].astype(str) + "-" + df["address"].astype(str)
            if "timestamp" in df.columns:
                df = df.set_index("timestamp")
            original_len = len(df)
            cleaned = remove_inactive_lead_time(df, logger=lambda *args: None)
            # After removing inactive lead time, we should have equal or fewer rows
            assert len(cleaned) <= original_len
            # The cleaned data should still have valid share prices
            assert len(cleaned) > 0
            share_prices = cleaned["share_price"].dropna()
            assert len(share_prices) > 0
    ''')

    test_path.write_text(test_content)
    print(f"Wrote {test_path}")
    print(f"\nRun with:\n  source .local-test.env && poetry run pytest {test_path} -v")


if __name__ == "__main__":
    main()
